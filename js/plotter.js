// Generated by CoffeeScript 1.7.1

/*
TO DO

- Log circle data on hover
  - Click & compare two values?

- Per game rate stats

- Set chart dimensions on each render

- Errors should appear next to the appropriate sections, not in a log box.

- LocalStorage
 */
var $cVal, $cVar, $hoverSpans, $html, $player, $ppInputs, $rVal, $rVar, $xVal, $xVar, $yVal, $yVar, calculateScales, chartHeight, chartPadding, chartWidth, circleCursorIn, circleCursorOut, datasetURL, drawChart, fullDataset, getGraphingData, getSelected, highlightModeSwitch, highlightModeUpdate, namesURL, perGameStats, playerPosSwitch, plottr, posColors, removeValues, render, scaleVals, scales, selectHTML, selected, statAbbr, validateInput,
  __slice = [].slice;

window.scatterplotter = plottr = {};

scales = {};

scaleVals = {};

$html = $('html');

statAbbr = {
  PassComp: "Pass Completions",
  PassAtt: "Pass Attempts",
  PassYds: "Pass Yards",
  PassTD: "Pass Touchdowns",
  PassINT: "Interceptions",
  RushAtt: "Rushing Attempts",
  RushYds: "Rushing Yards",
  RushTD: "Rushing Touchdowns",
  RushYPA: "Yards Per Rush",
  Recs: "Receptions",
  RecYards: "Receiving Yards",
  RecYPR: "Yards Per Reception",
  RecTD: "Receiving Touchdowns",
  ScrimYds: "Total Scrimmage Yards",
  TotalTD: "Total Touchdowns",
  FantPt: "Fantasy Points",
  PosRank: "Fantasy Position Rank",
  VBD: "VBD Points",
  OvRank: "Overall VBD Rank",
  Season: "Season",
  Age: "Age",
  G: "Games Played",
  GS: "Games Started"
};

perGameStats = ['PassComp', 'PassAtt', 'PassYds', 'PassTD', 'PassINT', 'RushAtt', 'RushYds', 'RushTD', 'RecYards', 'RecTD', 'FantPt', 'VBD', 'ScrimYds', 'TotalTD'];

posColors = {
  QB: "#3498db",
  RB: "#1abc9c",
  TE: "#f1c40f",
  WR: "#e67e22"
};

datasetURL = "/data/dataset.08-12.json";

namesURL = "/data/names.08-12.json";

selected = {};

fullDataset = {};

$.getJSON(datasetURL, function(json) {
  fullDataset = json;
  window.fantasyData = json;
});

$.getJSON(namesURL, function(json) {
  var html, player, _i, _len;
  html = "";
  for (_i = 0, _len = json.length; _i < _len; _i++) {
    player = json[_i];
    html += "<option>" + player + "</option>";
  }
  $("#player-select").append(html).chosen({
    width: "100%"
  });
});

chartWidth = $('.column').width();

chartHeight = chartWidth * 0.5;

chartPadding = 100;

selectHTML = $('select#original').html();

$('select.variable').html(selectHTML).chosen({
  allow_single_deselect: true,
  width: "75%"
});

$("#render-button").click(function() {
  if (!$html.is(".plotter-highlight-mode")) {
    return render();
  }
});

$("#highlight-button").click(function() {
  if ($("#scatterplot-wrapper").has("svg")) {
    $html.toggleClass("plotter-highlight-mode");
    return highlightModeSwitch();
  }
});

$ppInputs = $("input[name='pp-type']");

$("[data-input-group='players'], [data-input-group='positions']").hide();

$ppInputs.change(function() {
  return playerPosSwitch($(this).val());
});

render = function() {
  var graphingData;
  selected = {
    seasons: getSelected.seasons(),
    positions: getSelected.positions(),
    players: getSelected.players(),
    variables: getSelected.variables(),
    sortType: getSelected.sortType(),
    stat: getSelected.stat()
  };
  plottr.vars = selected.variables;
  if (validateInput(selected)) {

    /*
     */
    console.log("validateInput satified...");
    graphingData = getGraphingData(selected, fullDataset);
    scales = calculateScales(selected, graphingData);
    drawChart(graphingData, selected, scales);
  }
};

getSelected = {
  seasons: function() {
    var season, _i, _len, _ref, _results;
    _ref = $('.yr-input:checked');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      season = _ref[_i];
      _results.push($(season).val());
    }
    return _results;
  },
  positions: function() {
    var position, _i, _len, _ref, _results;
    _ref = $('.pos-input:checked');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      position = _ref[_i];
      _results.push($(position).val());
    }
    return _results;
  },
  players: function() {
    var player, _i, _len, _ref, _results;
    _ref = $(".search-choice span");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      player = _ref[_i];
      _results.push($(player).html());
    }
    return _results;
  },
  variables: function() {
    var values, variable, _i, _len, _ref;
    values = {};
    _ref = $("select.variable");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      variable = _ref[_i];
      values[$(variable).attr("data-axis")] = $(variable).find(":selected").attr("data-stat");
    }
    return values;
  },
  sortType: function() {
    return $("#pos-player-pair-holder input:checked").val();
  },
  stat: function() {
    return $("#avg-total-pair-holder input:checked").val();
  }
};

validateInput = function(input) {

  /*
   */
  var html;
  console.log("validateInput started...");
  console.log(input);
  $('.errors > :not(.error-close)').remove();
  html = "";
  if (!input.sortType) {
    html += "<p>No sort type (players/positions) selected.</p>";
  } else {
    if (input.sortType === "players" && !input.players.length) {
      html += "<p>No players selected.</p>";
    } else if (input.sortType === "positions" && !input.positions.length) {
      html += "<p>No positions selected.</p>";
    }
  }
  if (!input.seasons.length) {
    html += "<p>No seasons selected.</p>";
  }
  if (!input.stat) {
    html += "<p>No stat type (game/season) selected</p>";
  }
  if (!input.variables.xAxis) {
    html += "<p>No x-axis variable selected.</p>";
  }
  if (!input.variables.yAxis) {
    html += "<p>No y-axis variable selected.</p>";
  }
  if (html.length) {
    $(".errors").append("<h4>Uh oh, something went wrong</h4>" + html).slideDown();

    /*
     */
    console.log("validateInput() returning false");
    console.log(html);
    return false;
  } else {
    $(".errors").slideUp();

    /*
     */
    console.log("validateInput() returning true");
    return true;
  }
};

getGraphingData = function(sel, data) {

  /*
   */
  var dataPoints, match, name, player, position, season, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
  console.log("getGraphingData started...");
  console.log("sel:");
  console.log(sel);
  console.log("data:");
  console.log(data);
  dataPoints = [];
  if (sel.sortType === "positions") {
    _ref = sel.seasons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      season = _ref[_i];
      _ref1 = sel.positions;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        position = _ref1[_j];
        _ref2 = fullDataset[season][position];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          player = _ref2[_k];
          dataPoints.push(player);
        }
      }
    }
  } else if (sel.sortType === "players") {
    _ref3 = sel.seasons;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      season = _ref3[_l];
      _ref4 = fullDataset[season];
      for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
        position = _ref4[_m];
        _ref5 = sel.players;
        for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
          name = _ref5[_n];
          console.log(name);
          match = fullDataset[season][position].filter(function(player) {
            return player.Name === name;
          });
          if (match.length) {
            dataPoints.push(match);
          }
        }
      }
    }
  }
  return dataPoints;
};

calculateScales = function(sel, data) {

  /*
   */
  var datum, v, _i, _len;
  console.log("calculateScales started...");
  console.log(sel);
  console.log(data);
  scales = {};
  scaleVals = {
    x: {
      min: 1000000,
      max: 0
    },
    y: {
      min: 1000000,
      max: 0
    },
    r: {
      min: 1000000,
      max: 0
    },
    c: {
      min: 1000000,
      max: 0
    }
  };
  for (_i = 0, _len = data.length; _i < _len; _i++) {
    datum = data[_i];
    v = sel.variables;
    if (datum[v.xAxis] > scaleVals.x.max) {
      scaleVals.x.max = datum[v.xAxis];
    }
    if (datum[v.xAxis] < scaleVals.x.min) {
      scaleVals.x.min = datum[v.xAxis];
    }
    if (datum[v.yAxis] > scaleVals.y.max) {
      scaleVals.y.max = datum[v.yAxis];
    }
    if (datum[v.yAxis] < scaleVals.y.min) {
      scaleVals.y.min = datum[v.yAxis];
    }
    if (datum[v.rAxis] > scaleVals.r.max) {
      scaleVals.r.max = datum[v.rAxis];
    }
    if (datum[v.rAxis] < scaleVals.r.min) {
      scaleVals.r.min = datum[v.rAxis];
    }
    if (datum[v.cAxis] > scaleVals.c.max) {
      scaleVals.c.max = datum[v.cAxis];
    }
    if (datum[v.cAxis] < scaleVals.c.min) {
      scaleVals.c.min = datum[v.cAxis];
    }
  }
  scales.x = d3.scale.linear().domain([scaleVals.x.min, scaleVals.x.max]).range([chartPadding, chartWidth - chartPadding]);
  scales.y = d3.scale.linear().domain([scaleVals.y.max, scaleVals.y.min]).range([chartPadding, chartHeight - chartPadding]);
  scales.r = d3.scale.linear().domain([scaleVals.r.min, scaleVals.r.max]).range([2, 10]);
  scales.c = d3.scale.linear().domain([scaleVals.c.min, scaleVals.c.max]).range([-0.10, 0.10]);
  return scales;
};

drawChart = function(dataset, selected, scales) {

  /*
   */
  var c, dot, pieces, r, scatterplot, scatterplotPoints, x, xAxis, y, yAxis, _i, _len, _ref;
  console.log("drawChart started");
  console.log(dataset);
  console.log(selected);
  console.log(scales);
  $("#scatterplot-wrapper svg").remove();
  x = selected.variables.xAxis;
  y = selected.variables.yAxis;
  c = selected.variables.cAxis;
  r = selected.variables.rAxis;
  scatterplot = d3.select('#scatterplot-wrapper').append('svg').attr('id', 'the-scatterplot');
  scatterplotPoints = scatterplot.selectAll("circle").data(dataset).enter().append("circle").attr("cx", function(d) {
    return scales.x(d[x]);
  }).attr("cy", function(d) {
    return scales.y(d[y]);
  }).attr("r", function(d) {
    if (scales.r && d[r]) {
      return scales.r(d[r]);
    } else {
      return 4;
    }
  }).attr("fill", function(d) {
    var base;
    base = posColors[d.FantPos];
    if (scales.c && d[c]) {
      if (scales.c(d[c]) > 0) {
        return Color(base).lightenByAmount(scales.c(d[c])).desaturateByAmount(scales.c(d[c])).toCSS();
      } else {
        return Color(base).darkenByAmount(0 - scales.c(d[c])).saturateByAmount(0 - scales.c(d[c])).toCSS();
      }
    } else {
      return base;
    }
  }).attr("id", function(d) {
    var id;
    id = "";
    id += d.Name.split(" ").join("-") + "_";
    id += d.Season + "_";
    id += d.FantPos;
    return id;
  });
  xAxis = d3.svg.axis().scale(scales.x).orient("bottom");
  yAxis = d3.svg.axis().scale(scales.y).orient("left");
  scatterplot.append("g").attr("class", "axis").attr("id", "xAxis").attr("transform", "translate(0," + (chartHeight - chartPadding) + ")").call(xAxis);
  scatterplot.append("g").attr("class", "axis").attr("id", "yAxis").attr("transform", "translate(" + chartPadding + ",0)").call(yAxis);
  _ref = $("svg circle");
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    dot = _ref[_i];
    pieces = dot.id.split("_");
    $(dot).attr("data-player-name", pieces[0].split("-").join(" "));
    $(dot).attr("data-player-season", pieces[1]);
    $(dot).attr("data-player-position", pieces[2]);
  }
  plottr.svgDomElement = $("#scatterplot-wrapper").find("svg")[0];
  plottr.svgDomElement.setAttribute('preserveAspectRatio', 'xMinYMin meet');
  return plottr.svgDomElement.setAttribute("viewBox", "0 0 800 400");
};

removeValues = function() {
  var array, spot, value, values, _i, _len;
  array = arguments[0], values = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = values.length; _i < _len; _i++) {
    value = values[_i];
    if ((spot = array.indexOf(value)) !== -1) {
      array.splice(spot, 1);
    }
  }
  return array;
};

highlightModeUpdate = function($el, status, highlighted) {
  var position, season, value, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results, _results1, _results2;
  value = $el.val();
  if (status === true) {
    if ($el.is(".pos-input:checked")) {
      highlighted.positions.push(value);
    } else if ($el.is(".yr-input:checked")) {
      highlighted.seasons.push(value);
    }
  } else if (status === false) {
    if ($el.is(".pos-input:checked")) {
      removeValues(highlighted.positions, value);
    } else if ($el.is(".yr-input:checked")) {
      removeValues(highlighted.seasons, value);
    }
  }
  $("circle").attr("class", "");
  if (highlighted.seasons.length && highlighted.positions.length) {
    _ref = highlighted.seasons;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      season = _ref[_i];
      _results.push((function() {
        var _j, _len1, _ref1, _results1;
        _ref1 = highlighted.positions;
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          position = _ref1[_j];
          _results1.push($("circle[data-player-season='" + season + "']").filter("[data-player-position='" + position + "']").attr("class", "highlighted-dot").each(function() {
            return $(this).before($("#xAxis"));
          }));
        }
        return _results1;
      })());
    }
    return _results;
  } else {
    if (highlighted.seasons.length) {
      _ref1 = highlighted.seasons;
      _results1 = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        season = _ref1[_j];
        _results1.push($("circle[data-player-season='" + season + "']").attr("class", "highlighted-dot").each(function() {
          return $(this).before($("#xAxis"));
        }));
      }
      return _results1;
    } else if (highlighted.positions.length) {
      _ref2 = highlighted.positions;
      _results2 = [];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        position = _ref2[_k];
        _results2.push($("circle[data-player-position='" + position + "']").attr("class", "highlighted-dot").each(function() {
          return $(this).before($("#xAxis"));
        }));
      }
      return _results2;
    }
  }
};

highlightModeSwitch = function() {
  var highlighted, key, value;
  highlighted = {
    positions: [],
    players: [],
    seasons: []
  };
  if ($html.is(".plotter-highlight-mode")) {
    console.log('highlightmodeswitch if');
    $("input[type='checkbox']").prop("disabled", true);
    return $(".check-label").bind("click.highlightMode", function() {
      var $inputElement;
      $(this).toggleClass("highlighted");
      $inputElement = $("#" + $(this).attr("for"));
      return highlightModeUpdate($inputElement, $(this).is(".highlighted"), highlighted);
    });
  } else {
    console.log('highlightModeSwitch else');
    $("input[type='checkbox']").prop("disabled", false);
    $(".check-label").removeClass("highlighted");
    $(".check-label").unbind("click.highlightMode");
    $("circle").attr("class", "");
    for (key in highlighted) {
      value = highlighted[key];
      value = [];
    }
  }
};

playerPosSwitch = function(val) {
  var $toHide, $toShow;
  $toShow = $("[data-input-group='" + val + "']").eq(0);
  $toHide = $toShow.siblings("[data-input-group]").eq(0);
  if ($toHide.is(":visible")) {
    $toHide.fadeOut(250, function() {
      $toShow.fadeIn(250);
    });
  } else {
    $toShow.fadeIn(250);
  }
};

$hoverSpans = $(".hover-data span");

$player = $("#player-name-year");

$xVar = $("#x-axis-data-name");

$yVar = $("#y-axis-data-name");

$rVar = $("#r-axis-data-name");

$cVar = $("#c-axis-data-name");

$xVal = $("#x-axis-data-value");

$yVal = $("#y-axis-data-value");

$rVal = $("#r-axis-data-value");

$cVal = $("#c-axis-data-value");

$("body").on("mouseenter", "#scatterplot-wrapper circle", function() {
  return circleCursorIn("#" + this.id);
});

$("body").on("mouseleave", "#scatterplot-wrapper circle", function() {
  return circleCursorOut();
});

circleCursorIn = function(selector) {
  var props, v;
  props = d3.select(selector)[0][0].__data__;
  v = plottr.vars;
  $player.html("" + props.Name + " – " + props.Season + " (" + props.FantPos + ", " + props.Tm + ")");
  $xVar.html(" " + v.xAxis + " ");
  $yVar.html(" " + v.yAxis + " ");
  $rVar.html(" " + v.rAxis + " ");
  $cVar.html(" " + v.cAxis + " ");
  $xVal.html(props[v.xAxis]);
  $yVal.html(props[v.yAxis]);
  $rVal.html(props[v.rAxis]);
  return $cVal.html(props[v.cAxis]);
};

circleCursorOut = function() {
  return $hoverSpans.html("&nbsp;");
};


/*
charter.xName.html(charter.selections.selectedVariables.xAxis)
    charter.yName.html(charter.selections.selectedVariables.yAxis)
    charter.rName.html(charter.selections.selectedVariables.rAxis)
    charter.cName.html(charter.selections.selectedVariables.cAxis)
    
    $('#the-scatterplot circle').mouseenter(function(e) {
        var d = charter.theChart.select('#' + this.id);
        
        var id = this.id.split("_");
        
        charter.nameSeason.html(id[0].split("-").join(" ") + " â€“ " + id[1] + " â€“ " + id[2]);
        charter.xVal.html(d[0][0].__data__[0]);
        charter.yVal.html(d[0][0].__data__[1]);
        charter.rVal.html(d[0][0].__data__[2]);
        charter.cVal.html(d[0][0].__data__[3]);
    });
 */
